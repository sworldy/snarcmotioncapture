C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE USB_MAIN
OBJECT MODULE PLACED IN USB_MAIN.OBJ
COMPILER INVOKED BY: C:\Program Files\keil\C51\BIN\C51.exe USB_MAIN.c DB OE

line level    source

   1          //-----------------------------------------------------------------------------
   2          // 单个16405sensor(只有spi)的数据采集，采样率设为100hz
   3          
   4          //      TH0 = 0xb1;     TL0= 0xde;采样率设为50hz
   5          //      TH0 = 0xd8;     TL0= 0xee;采样率设为100hz
   6          //-----------------------------------------------------------------------------
   7          #include "c8051f340.h"       
   8          #include <stddef.h>       
   9          #include "USB_API.h"
  10          //#include"port.h"
  11          #define IN_PACKET_SIZE 304
  12          #define uchar unsigned char          //定义一下方便使用
  13          #define uint  unsigned int
  14          #define ulong unsigned long
  15          //#define WriteDeviceAddress  0x3c     //定义器件在IIC总线中的地址
  16          //#define ReadDviceAddress   0x3d
  17          xdata BYTE In_Packet[IN_PACKET_SIZE];
  18          //xdata BYTE Temper[10][6];
  19          bit flag=0;
  20          bit SDT=0;
  21          bit SDQ=0;
  22          int read_data1=1;
  23          int read_data2=1;
  24          //int Temper[6];
  25          //int number=0;
  26          /*** [BEGIN] USB Descriptor Information [BEGIN] ***/
  27          code const UINT USB_VID = 0x10C4;
  28          code const UINT USB_PID = 0xEA61;
  29          code const BYTE USB_MfrStr[] = {0x1A,0x03,'S',0,'i',0,'l',0,'i',0,'c',0,'o',0,'n',0,' ',0,'L',0,'a',0,'b',
             -0,'s',0};                             // Manufacturer String
  30          code const BYTE USB_ProductStr[] = {0x10,0x03,'U',0,'S',0,'B',0,' ',0,'A',0,'P',0,'I',0};       //      Product Desc.
             - String
  31          code const BYTE USB_SerialStr[] = {0x0A,0x03,'1',0,'2',0,'3',0,'4',0};
  32          code const BYTE USB_MaxPower = 15;            // Max current = 30 mA (15 * 2)
  33          code const BYTE USB_PwAttributes = 0x80;      // Bus-powered, remote wakeup not supported
  34          code const UINT USB_bcdDevice = 0x0100;       // Device release number 1.00
  35          /*** [ END ] USB Descriptor Information [ END ] ***/
  36          
  37          
  38                  
  39          void Port_Init(void);
  40          void  SPI_Init(void);
  41          void TIMER0_Init(void);
  42          void ADIS16250_init(void);
  43          void Suspend_Device(void);
  44          void InitializeData();
  45          //void PrepareData();
  46          //void PrepareData2();
  47          void  SPI_senddata(int);
  48          void  SPI_readdata_first(int);
  49          void  SPI_readdata_next(int);
  50          
  51          ////////////////////////////////////////////
  52          ////////HMC5843
  53          ////////////////////////////////////////////
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 2   

  54          /*-------------起始位状态：SCL为高时，SDA线由高到低跳变，之后经延时后SCL由高到低跳变
  55                         停止位状态：SCL为高时，SDA线由低到高跳变
  56                         ------------------------------------------------*/
  57          
  58          /********************************************************************/
  59          void DelayMs(unsigned int number)     //定时函数
  60          {
  61   1      
  62   1      unsigned char temp;
  63   1      for(;number!=0;number--) {for(temp=0;temp!=0;temp--);}
  64   1      }
  65          ///////////////////////////////////////////
  66          ///////////////////////////////////////////
  67          
  68          
  69          //-----------------------------------------------------------------------------
  70          // Main Routine
  71          //-----------------------------------------------------------------------------
  72          void main(void) 
  73          {
  74   1      
  75   1         PCA0MD &= ~0x40;                       // Disable Watchdog timer
  76   1       //  CLKSEL =  0x03; 
  77   1         OSCICN |= 0x03; 
  78   1         EA            = 1;    //开启总中断 
  79   1         
  80   1         SPI_Init();
  81   1         Port_Init();
  82   1       //  ADIS16250_init();
  83   1              
  84   1         USB_Clock_Start();                     // Init USB clock *before* calling USB_Init
  85   1         USB_Init(USB_VID,USB_PID,USB_MfrStr,USB_ProductStr,USB_SerialStr,USB_MaxPower,USB_PwAttributes,USB_bcdD
             -evice); 
  86   1         USB_Int_Enable();
  87   1        
  88   1         
  89   1         
  90   1      
  91   1      /*      P3=0x04;
  92   1      //      SPI_senddata(0xb607);
  93   1              SPI_senddata(0xb4C6);
  94   1              SPI_senddata(0xbe01);
  95   1      //      SPI_senddata(0xbe10);
  96   1              DelayMs(10);
  97   1      //      SPI_senddata(0xb807);
  98   1      
  99   1              P3=0x05;
 100   1              SPI_senddata(0xb4C6);
 101   1              SPI_senddata(0xbe01);
 102   1              DelayMs(10);
 103   1      //      SPI_senddata(0xb807);
 104   1      
 105   1              P3=0x06;
 106   1              SPI_senddata(0xb4C6);
 107   1              SPI_senddata(0xbe01);
 108   1              DelayMs(10);
 109   1      //      SPI_senddata(0xb807);
 110   1      
 111   1              P3=0x08;
 112   1              SPI_senddata(0xb4C6);
 113   1              SPI_senddata(0xbe01);
 114   1              DelayMs(10);
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 3   

 115   1      //      SPI_senddata(0xb807);
 116   1      
 117   1              P3=0x09;
 118   1              SPI_senddata(0xb4C6);
 119   1              SPI_senddata(0xbe01);
 120   1              DelayMs(10);
 121   1      //      SPI_senddata(0xb807);
 122   1      
 123   1              P3=0x0A;
 124   1              SPI_senddata(0xb4C6);
 125   1              SPI_senddata(0xbe01);
 126   1              DelayMs(10);
 127   1      //      SPI_senddata(0xb807);
 128   1      
 129   1              P3=0x0B;
 130   1              SPI_senddata(0xb4C6);
 131   1              SPI_senddata(0xbe01);
 132   1              DelayMs(10);
 133   1      //      SPI_senddata(0xb807);
 134   1      
 135   1              P3=0x010;
 136   1              SPI_senddata(0xb4C6);
 137   1              SPI_senddata(0xbe01);
 138   1              DelayMs(10);
 139   1      //      SPI_senddata(0xb807);
 140   1      
 141   1              P3=0x011;
 142   1              SPI_senddata(0xb4C6);
 143   1              SPI_senddata(0xbe01);
 144   1              DelayMs(10);
 145   1      //      SPI_senddata(0xb807);
 146   1      
 147   1              P3=0x12;
 148   1              SPI_senddata(0xb4C6);
 149   1              SPI_senddata(0xbe01);
 150   1              DelayMs(10);
 151   1      //      SPI_senddata(0xb807);
 152   1      
 153   1              P3=0x020;
 154   1              SPI_senddata(0xb4C6);
 155   1              SPI_senddata(0xbe01);
 156   1              DelayMs(10);
 157   1      //      SPI_senddata(0xb807);
 158   1      
 159   1              P3=0x021;
 160   1              SPI_senddata(0xb4C6);
 161   1              SPI_senddata(0xbe01);
 162   1              DelayMs(10);
 163   1      //      SPI_senddata(0xb807);
 164   1      
 165   1              
 166   1              P3=0x022;
 167   1              SPI_senddata(0xb4C6);
 168   1              SPI_senddata(0xbe01);
 169   1              DelayMs(10);
 170   1      //      SPI_senddata(0xb807);
 171   1      
 172   1              P3=0x040;
 173   1              SPI_senddata(0xb4C6);
 174   1              SPI_senddata(0xbe01);
 175   1              DelayMs(10);
 176   1      //      SPI_senddata(0xb807);
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 4   

 177   1      
 178   1              P3=0x041;
 179   1              SPI_senddata(0xb4C6);
 180   1              SPI_senddata(0xbe01);
 181   1              DelayMs(10);
 182   1      //      SPI_senddata(0xb807);
 183   1      
 184   1              P3=0x042;
 185   1              SPI_senddata(0xb4C6);
 186   1              SPI_senddata(0xbe01);
 187   1              DelayMs(10);
 188   1      //      SPI_senddata(0xb807);
 189   1      
 190   1      */
 191   1      //      SPI_senddata(0xbe08);
 192   1        // ADIS16250_init();*/
 193   1      
 194   1         
 195   1         TIMER0_Init();
 196   1        // SPI_BUSY=1;
 197   1         while (1);
 198   1      }
 199          void InitializeData()
 200          {       
 201   1              unsigned int x=0;
 202   1              for(; x < IN_PACKET_SIZE; ++x)
 203   1                      In_Packet[x] = 0;
 204   1      }
 205          void PrepareData()
 206          {
 207   1          unsigned int x=0,num=1,i=0,j=0,temp=0;
 208   1              //P3=0x04;
 209   1              
 210   1           for(i=0;i<16;i++)
 211   1               {
 212   2              if(num==1)
 213   2                      {
 214   3                              P3=0x04;
 215   3                      }
 216   2                      else if(num==2)
 217   2                      {
 218   3                              P3=0x05;
 219   3                      }
 220   2                      else if(num==3)
 221   2                      {
 222   3                              P3=0x06;
 223   3                      }
 224   2                      else if(num==4)
 225   2                      {
 226   3                              P3=0x08;
 227   3                      }
 228   2                      else if(num==5)
 229   2                      {
 230   3                              P3=0x09;
 231   3                      }
 232   2                      else if(num==6)
 233   2                      {
 234   3                              P3=0x0a;
 235   3                      }
 236   2                      else if(num==7)
 237   2                      {
 238   3                              P3=0x0b;
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 5   

 239   3                      }
 240   2                      else if(num==8)
 241   2                      {
 242   3                              P3=0x10;
 243   3                      }
 244   2                      else if(num==9)
 245   2                      {
 246   3                              P3=0x11;
 247   3                      }
 248   2                      else if(num==10)
 249   2                      {
 250   3                              P3=0x12;
 251   3                      }
 252   2                      else if(num==11)
 253   2                      {
 254   3                              P3=0x20;
 255   3                      }
 256   2                      else if(num==12)
 257   2                      {
 258   3                              P3=0x21;
 259   3                      }
 260   2                      else if(num==13)
 261   2                      {
 262   3                              P3=0x22;
 263   3                      }
 264   2                      else if(num==14)
 265   2                      {
 266   3                              P3=0x40;
 267   3                      }
 268   2                      else if(num==15)
 269   2                      {
 270   3                              P3=0x41;
 271   3                      }
 272   2                      else if(num==16)
 273   2                      {
 274   3                              P3=0x42;
 275   3                      }
 276   2      
 277   2                      In_Packet[x]=num;
 278   2                              num++;
 279   2                      SPI_readdata_first(0x0a);
 280   2                      x++;
 281   2                      SPI_readdata_next(0x0c);
 282   2                      In_Packet[x]=read_data1;
 283   2                      x++;
 284   2                      In_Packet[x]=read_data2;
 285   2                      x++;
 286   2                      SPI_readdata_next(0x0e);
 287   2                      In_Packet[x]=read_data1;
 288   2                      x++;
 289   2                      In_Packet[x]=read_data2;
 290   2                      x++;
 291   2                      SPI_readdata_next(0x04);
 292   2                      In_Packet[x]=read_data1;
 293   2                      x++;
 294   2                      In_Packet[x]=read_data2;
 295   2                      x++;
 296   2                      SPI_readdata_next(0x06);
 297   2                      In_Packet[x]=read_data1;
 298   2                      x++;
 299   2                      In_Packet[x]=read_data2;
 300   2                      x++;
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 6   

 301   2                      SPI_readdata_next(0x08);
 302   2                      In_Packet[x]=read_data1;
 303   2                      x++;
 304   2                      In_Packet[x]=read_data2;
 305   2                      x++;
 306   2                      SPI_readdata_next(0x10);
 307   2                      In_Packet[x]=read_data1;
 308   2                      x++;
 309   2                      In_Packet[x]=read_data2;
 310   2                      x++;
 311   2                      SPI_readdata_next(0x12);
 312   2                      In_Packet[x]=read_data1;
 313   2                      x++;
 314   2                      In_Packet[x]=read_data2;
 315   2                      x++;
 316   2                      SPI_readdata_next(0x14);
 317   2                      In_Packet[x]=read_data1;
 318   2                      x++;
 319   2                      In_Packet[x]=read_data2;
 320   2                      x++;
 321   2      
 322   2                      SPI_readdata_next(0x00);
 323   2                      In_Packet[x]=read_data1;
 324   2                      x++;
 325   2                      In_Packet[x]=read_data2;
 326   2              x++;
 327   2              //      
 328   2           }
 329   1      }
 330          //-----------------------------------------------------------------------------
 331          // Initialization Subroutines
 332          //-----------------------------------------------------------------------------
 333          
 334          //-------------------------
 335          // Port_Init
 336          //-------------------------
 337          // Port Initialization
 338          // - Configure the Crossbar and GPIO ports.
 339          //
 340          void Port_Init(void)
 341          {  
 342   1         P0MDOUT  =0x0f;
 343   1         P0SKIP        = 0xf8;
 344   1         P1SKIP        = 0x3f;
 345   1       
 346   1         XBR0      = 0x02;    //设置SPI使能                                      
 347   1         XBR1      = 0x40;    //交叉开关使能               
 348   1         //P0MDOUT   = 0x10;    //p0.4 推挽方式   输出    
 349   1       //  P1MDOUT   = 0x0f;    
 350   1        P1MDOUT=0x00;
 351   1       //  P1MDIN=0x80;
 352   1         P2MDOUT=0x00;
 353   1      
 354   1         P3MDOUT=0xff;
 355   1        // P0MDOUT |= 0x05;
 356   1       //  P0=0xff;
 357   1      
 358   1      }
 359          /****************************************************************
 360          *
 361          *定时器初始化函数
 362          *****************************************************************/
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 7   

 363          
 364          void  TIMER0_Init(void)
 365          {
 366   1        // SCON0    = 0x10;                                                            
 367   1         CKCON     = 0x08;
 368   1       //  TH0       = 0xF6;          
 369   1       //  TL0       = 0x74;   
 370   1        // TH0       = 0xd8;          
 371   1        // TL0       = 0xef;  
 372   1          TH0       = 0xd8;           
 373   1         TL0       = 0xee;                      
 374   1         TMOD      |= 0x01;      //16位计数器
 375   1         
 376   1         PT0           = 1;
 377   1         ET0           = 0;                  
 378   1         TR0       = 1;                           
 379   1        // TI0       = 1;     
 380   1      }
 381          void TIMER0_ISR(void) interrupt 1
 382          {
 383   1       //  unsigned int x=0,num=1,i=0;
 384   1       //  PT0                 = 0;
 385   1         TR0       = 0; 
 386   1         TH0       = 0xd8;            
 387   1         TL0       = 0xee;
 388   1         flag=1;
 389   1      //      PT0              = 1;
 390   1      }
 391          /****************************************************************
 392          *
 393          *SPI初始化函数
 394          *****************************************************************/
 395          void SPI_Init(void)
 396          {
 397   1          ESPI0     = 0;
 398   1              PSPI0     = 0;
 399   1              SPI0CFG   = 0x70;
 400   1          SPI0CN    = 0x01;
 401   1          SPI0CKR   = 0x03;  //1500khz
 402   1          SPIF=0;
 403   1      }
 404          
 405          /****************************************************************/
 406          /*****************************************************************
 407          *
 408          *I/O口模拟SPI收发数据
 409          *****************************************************************/
 410          void SPI_senddata(int command)
 411          {
 412   1         int a,i;
 413   1         a=command;
 414   1       //  SPIF=0;
 415   1      
 416   1         SPI0DAT  = (a&0xff00)/256;
 417   1         while(SPIF==0);  
 418   1         SPIF=0;  
 419   1         SPI0DAT = (a&0x00ff);
 420   1         while(SPIF==0);
 421   1         SPIF=0;
 422   1      
 423   1        //    for(i=0;i<5;i++); 
 424   1      }
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 8   

*** WARNING C280 IN LINE 412 OF USB_MAIN.C: 'i': unreferenced local variable
 425          
 426          void  SPI_readdata_first(int address)
 427          {
 428   1              int a,i;
 429   1              a=address; 
 430   1              SPIF=0;
 431   1              SPI0DAT = a;
 432   1              while(SPIF==0); 
 433   1              SPIF=0; 
 434   1              SPI0DAT = 0;
 435   1              while(SPIF==0);
 436   1              SPIF=0;
 437   1              for(i=0;i<5;i++);  // 必须有个时间间隔
 438   1      }
 439          void  SPI_readdata_next(int address)
 440          {
 441   1          int a,i;
 442   1              a=address; 
 443   1              for(i=0;i<10;i++); 
 444   1              SPI0DAT = a;  
 445   1              while(SPIF==0);
 446   1              SPIF=0;
 447   1              read_data1 = SPI0DAT;
 448   1              SPI0DAT = 0; 
 449   1              for(i=0;i<5;i++);  
 450   1              while(SPIF==0);
 451   1              SPIF=0;
 452   1              read_data2 = SPI0DAT;
 453   1      }
 454          /*****************************************************************
 455          *
 456          *ASIS16350初始化函数
 457          *****************************************************************/
 458          void ADIS16250_init()
 459          {
 460   1        //  int i,j;
 461   1              SPI_senddata(0xb807);
 462   1      
 463   1       //  for(j=0;j<200;j++) 
 464   1      //      {
 465   1      //          for(i=0;i<2000;i++);
 466   1      //      }    
 467   1      
 468   1              
 469   1      //      SPI_senddata(0xbe02);
 470   1      
 471   1        //  for(j=0;j<200;j++) 
 472   1      //      {
 473   1      //          for(i=0;i<2000;i++);
 474   1      //      }    
 475   1      }
 476          /////////////////////////////////////////////////////////
 477          //      Example ISR for USB_API
 478          void    USB_API_TEST_ISR(void) interrupt 16
 479          {
 480   1              BYTE INTVAL = Get_Interrupt_Source();
 481   1              
 482   1              if      (INTVAL &       DEVICE_OPEN)                            
 483   1              {
 484   2                      InitializeData();
 485   2                      Block_Write(In_Packet, IN_PACKET_SIZE);
C51 COMPILER V8.08   USB_MAIN                                                              10/06/2009 10:17:52 PAGE 9   

 486   2                      ET0              = 1;
 487   2              }
 488   1              if (INTVAL & RX_COMPLETE)
 489   1              {
 490   2      
 491   2              }
 492   1              if (INTVAL & TX_COMPLETE)
 493   1              {
 494   2             while(flag==0);
 495   2                      flag=0;
 496   2                      TR0       = 1; 
 497   2                      PrepareData();
 498   2                      Block_Write(In_Packet, IN_PACKET_SIZE);
 499   2      //              while(flag==0);
 500   2      //              flag=0;
 501   2      //              PT0              = 1;
 502   2              }
 503   1              if (INTVAL & DEV_SUSPEND)
 504   1              {
 505   2            //  Suspend_Device();
 506   2              }
 507   1      
 508   1              if (INTVAL & DEV_CONFIGURED)
 509   1              {
 510   2                      Port_Init();
 511   2              }
 512   1              if      (INTVAL &       DEVICE_CLOSE)                           //      Device closed
 513   1              {
 514   2                      
 515   2              }
 516   1              if      (INTVAL &       FIFO_PURGE)                                     //      Fifo purged
 517   1              {
 518   2                      
 519   2              }
 520   1      
 521   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1212    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =    304    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
